<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Topical | Academic</title>
    <link>https://example.com/category/topical/</link>
      <atom:link href="https://example.com/category/topical/index.xml" rel="self" type="application/rss+xml" />
    <description>Topical</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 07 May 2022 18:30:00 +0000</lastBuildDate>
    <image>
      <url>https://example.com/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Topical</title>
      <link>https://example.com/category/topical/</link>
    </image>
    
    <item>
      <title>Управление версиями. Git</title>
      <link>https://example.com/post/git/</link>
      <pubDate>Sat, 07 May 2022 18:30:00 +0000</pubDate>
      <guid>https://example.com/post/git/</guid>
      <description>&lt;p&gt;Системы контроля модификаций (СКВ) позволяют отслеживать изменения в коде, просматривать историю для поиска определенных изменений, а также координировать работу над одной и той же базой кода между несколькими разработчиками.
Сегодня мы рассмотрим, как устроена одна из самых популярных СКВ &amp;ndash; Git.&lt;/p&gt;
&lt;h1 id=&#34;история&#34;&gt;История&lt;/h1&gt;
&lt;p&gt;Git был разработан в 2005 году Линусом Торвальдсом для помощи в разрботке ядра Linux. Незадолго до этого произошел скандал с Bitkeeper &amp;ndash; проприетарной системой контроля версий, которая использовалась многими разработчиками, но перестала быть бесплатно доступна после того, как правообладатель узнал, что она была обратно-разработана, чтобы создать SourcePuller.&lt;/p&gt;
&lt;p&gt;Целями проекта были: сделать распределенную СКВ, которая могла бы поддерживать процедуру, похожую на Bitkeeper, но также была быстрой (не более трех секунд на применение патча) и имела сильную защиту от ошибок и непреднамеренных модификаций.&lt;/p&gt;
&lt;h1 id=&#34;принципы&#34;&gt;Принципы&lt;/h1&gt;
&lt;p&gt;Примитивные структуры данных Git не обязательно реализуют СКВ. Существуют два места, где хранится информация &amp;ndash; динамический &lt;em&gt;индекс&lt;/em&gt;, который описывает состояние рабочего дерева, и неизменяемая &lt;em&gt;база данных объектов&lt;/em&gt;. В последней хранятся следующие пять типов объектов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BLOB &amp;ndash; содержимое файла, обозначаемое своим хешем. Каждый BLOB &amp;ndash; это отдельная версия файла.&lt;/li&gt;
&lt;li&gt;дерево &amp;ndash; это аналог директории, которая имеет ссылки на под-деревья и BLOB, чтобы представить одну версию рабочего дерева.&lt;/li&gt;
&lt;li&gt;коммит &amp;ndash; это элемент истории, указывающий на дерево, описываемое им, и на один или больше предыдущих коммитов.&lt;/li&gt;
&lt;li&gt;тэг &amp;ndash; объект, который имеет ссылку на какой-то другой объект и какую-то дополнительную информацию об этом объекте. Чаще всего используется для добавления цифровых подписей к коммитам.&lt;/li&gt;
&lt;li&gt;packfile &amp;ndash; файл, содержащий несколько других объектов в сжатом формате для компактности.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Из-за этого дизайна каждый репозиторий содержит всю историю и может быть просмотрен локально. Это то, что делает Git &lt;em&gt;распределенной&lt;/em&gt; СКВ.&lt;/p&gt;
&lt;p&gt;История коммитов устроена как односвязное дерево, и из-за того, что идентификаторы основаны на криптографическом хеше содержимого, это также можно воспринимать как экземпляр блокчейна. Каждый коммит может иметь родителя &amp;ndash; коммит, на основании которого сделаны изменения. С помощью них можно идти назад в историю изменений. Поскольку каждый коммит идентифицируется своим хешем, то любое изменение истории требует пересчета хеша каждого из объектов дальше, что предоставляет криптографическую защиту от изменений.&lt;/p&gt;
&lt;p&gt;В дополнение к этому Git хранит базу ссылок. Head-объекты указывают на последний коммит в ветке, называют ветку, и тем самым фактически являются ветками. Один особый head, называемый HEAD, указывает на текущую ветку, от который идет сравнение с рабочим деревом. Также существуют tags, которые, как и head, указывают на коммиты, но в отличие от них не двигаются, и вместо этого могут быть использованы для обозначения важных точек в истории проекта.&lt;/p&gt;
&lt;h1 id=&#34;процесс-ведения-истории&#34;&gt;Процесс ведения истории&lt;/h1&gt;
&lt;p&gt;Git не регламентирует, как именно следует вести историю проекта. Один из вариантов, который предполагается к использованию в курсе ОС, предполагает короткоживущие ветки, внутри которых производится работа по реализации новой фичи, и затем эта ветка сливается в основное дерево, когда фича завершена. Другие варианты включают долгоживущие ветки, ранжированные по стабильности кода, или ветки, закрепленные за определенными членами команды.&lt;/p&gt;
&lt;p&gt;Разные методы имеют свои плюсы и минусы, которые более или менее явно проявляются в зависимости от типа проекта и методологии разработки, которую использует команда.&lt;/p&gt;
&lt;h1 id=&#34;выводы&#34;&gt;Выводы&lt;/h1&gt;
&lt;p&gt;Git &amp;ndash; это одна из самых популярных СКВ, и это не случайно. Она была написана для того, чтобы разрешить проблемы с существовавшими СКВ, и она смогла решить их гораздо более эффективно, чем любые другие решения в то время.&lt;/p&gt;
&lt;p&gt;Одним из факторов ее популярности стало развитие сервисов хостинга Git, таких как GitHub, GitLab и BitBucket. Эти сервисы позволяют опубликовать Git-репозиторий и сделать его доступным из интернета, и их удобство привело к тому, что сейчас многие пользователи неразрывно ассоциируют Git с GitHub.&lt;/p&gt;
&lt;p&gt;Благодаря такой популярности, простоте казуального использования и при этом глубине функционала для продвинутого использования, Git теперь является необходимостью для любого рода разработки кода. Именно поэтому на курсе ОС мы изучаем основы использования Git.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
